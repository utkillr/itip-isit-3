2-1-3
Linear_Search(A, v) res
	res <- 0
	for i<-1 to length[A]
		if (A[i] = v) do
			res <- i

Инвариант - индекс искомого указывает на индекс элемента в массиве A[1..i], либо 0, если такового не имеется
1)	В начале i = 0, т.е. подмассив пустой.
2)	Перед каждой итерацией цикла res показывает верный результат:
		Перед первой это 0
		Перед остальными - значение с конца предыдущей итерации
	После каждой итерации цикла:
		Если элемент найден, то res содержит индекс элемента
		Иначе - 0 (=не найден)
3)	В конце алгоритма = в конце цикла.


2-2-2
Selection_Sort(A)					|Время	|Число			|
	for i<-1 to length[A]-1			|C1		|n				|
		index <- j					|C2		|n-1			|
		for j<-i+1 to length[A]		|C3		|S  Tj			|
			if (A[i] > A[j]) do		|C4		|S  Tj-1		|
				index <- i 			|C5		|S  Tj-1-Tjj	|
		key <- A[j]					|C6		|n-1			|
		A[j] <- A[index]			|C7		|n-1			|
		A[index] <- key				|C8		|n-1			|

Инвариант - все элементы в A[1..i] отсортированны
Его можно выполнить только для i до n-1, так как в результате при A[n-1]>A[n] ничего не произойдет, но для следующей итерации инвариант был бы выполнен, и, наоборот, при A[n-1]<A[n] произойдет обмен значениями и инвариант снова будет выполнен.

Tj - количество проверок условия цикла
Tjj - количество неверных проверок if

T(n) = C1n + C2(n-1) + C3*(S(1 to n-1) Tj) + C4*(S(1 to n-1) (Tj-1) + C5*(S(1 to n-1) (Tj-1-Tjj) + C6(n-1) + C7(n-1) + C8(n-1)
Tj всегда будет равно n-i+1:
C3*(S(1 to n-1) Tj) = C3*n*(n+1)/2
C4*(S(1 to n-1) (Tj-1) = C4*n*(n-1)/2

В худшем случае Tjj = 0
C5*(S(1 to n-1) (Tj-1-Tjj) = C5*n*(n-1)/2

В лучшем случае Tjj = Tj-1:
C5*(S(1 to n-1) (Tj-1-Tjj) = 0

Тогда в лучшем случае T(n) = C1n+(C2+C6+C7+C8)(n-1) + C3*n^2/2 + C3*n/2 + C4*n^2/2 - C4*n/2
В худшем случае же    T(n) = C1n+(C2+C6+C7+C8)(n-1) + C3*n^2/2 + C3*n/2 + C4*n^2/2 - C4*n/2 + C5*n^2/2 - C5*n/2

В любом случае, оба раза скорость будет teta(n^2)


2-2-3
Для линейного поиска в лучшем случае первый элемент искомый
В среднем случае - любой.
В худшем - последний

Linear_Search(A, v) res		|Время	|Повторений	|
	res <- 0				|C1 	|1			|
	for i<-1 to length[A]	|C2		|n+1		|
		if (A[i] = v) do	|C3		|n 			|
			res <- i 		|C4		|Tj*n 		|

Tj - количество верных проверок. В лучшем случае 1. В среднем - [n/2]
В лучшем случае T(n) = C1 + C2(n+1) + C3*n + C4*1
В среднем:		T(n) = C1 + C2(n+1) + C3*n + C4*[n/2]

В случае отсутствия безусловного выхода, T(n) = teta(n)

Linear_Search(A, v) res		|Время	|Повторений	|
	res <- 0				|C1 	|1			|
	for i<-1 to length[A]	|C2		|? n/2		|
		if (A[i] = v) do	|C3		|? n/2		|
			res <- i 		|C4		|1	 		|
			return res		|C5		|1	 		|
	return res				|C6		|1			|

В случае наличия выхода сразу при нахождении:
	В лучшем случае T(n) = C1 + C2 + C3 + C4 = 					teta(1)
	В среднем случае: T(n) = C1 + C2*([n/2] + 1) + C3*([n/2]) = teta(n)